###############################################################################
# 11-compiler-code-generation/compilation_engine.py
# -------------------------------------------------
# The CompilationEngine module receives parsed input from SyntaxAnalyzer and
# and compiles virtual machine (VM) code using VMWriter.
# 
# The output is generated by a series of `compile_<xxx>()` routines, one for
# every syntactic element <xxx> of the Jack grammar.
###############################################################################

import os

from symbol_table import SymbolTable
from vm_writer import VMWriter


class CompilationEngine:
    
    def __init__(self):
        """Creates a new compilation engine."""
        self._class_name = ""
        self._if_label_count = 0
        self._while_label_count = 0
        
    def compile_vm_code(self, input):
        table = SymbolTable(None)
        return os.linesep.join(self.compile_Class(input, table))

    def _count_locals(self, subroutine):
        count = 0
        for var_dec in subroutine.body.var_decs:
            count += len(var_dec.var_names)
        return count

    def _get_var_type(self, var_type):
        if var_type.__class__.__name__ == "Keyword":
            return var_type.keyword
        else:
            return var_type.identifier

    def compile_Class(self, jack_class, table):
        """Compiles a complete class."""
        output = []
        self._class_name = jack_class.class_name
        for class_var_dec in jack_class.class_var_decs:
            output.extend(self.compile_ClassVarDec(class_var_dec, table))
        for subroutine_dec in jack_class.subroutine_decs:
            output.extend(self.compile_SubroutineDec(subroutine_dec, table))
        return output
    
    def compile_ClassVarDec(self, var_dec, table):
        """Compiles a static declaration or a field declaration."""
        for var_name in var_dec.var_names:
            name = var_name.identifier
            var_type = self._get_var_type(var_dec.var_type.var_type)
            table.define(var_name.identifier, var_type, var_dec.scope.keyword)
        return []

    def compile_SubroutineDec(self, subroutine, table):
        """Compiles a constructor, function, or method declaration."""
        new_table = SymbolTable(table)
        subroutine_type = subroutine.subroutine_type.keyword
        return getattr(self, f"compile_{subroutine_type.capitalize()}Dec")(subroutine, new_table)

    def compile_FunctionDec(self, subroutine, table):
        """Compiles a function declaration."""
        for param in subroutine.parameter_list:
            var_type = self._get_var_type(param[0].var_type)
            var_name = param[1].identifier
            table.define(var_name, var_type, "argument")
            
        output = []
        output.extend(VMWriter.write_function(f"{self._class_name.identifier}.{subroutine.name.identifier}", self._count_locals(subroutine)))
        output.extend(self.compile_SubroutineBody(subroutine.body, table))
        return output

    def compile_MethodDec(self, subroutine, table):
        """Compiles a method declaration."""
        table.define("this", self._class_name.identifier, "argument")
        for param in subroutine.parameter_list:
            var_type = self._get_var_type(param[0].var_type)
            var_name = param[1].identifier
            table.define(var_name, var_type, "argument")

        output = []
        output.extend(VMWriter.write_function(f"{self._class_name.identifier}.{subroutine.name.identifier}", self._count_locals(subroutine)))
        output.extend(VMWriter.write_push("argument", 0))
        output.extend(VMWriter.write_pop("pointer", 0))
        output.extend(self.compile_SubroutineBody(subroutine.body, table))
        return output

    def compile_ConstructorDec(self, subroutine, table):
        """Compiles a constructor declaration."""
        for param in subroutine.parameter_list:
            var_type = self._get_var_type(param[0].var_type)
            var_name = param[1].identifier
            table.define(var_name, var_type, "argument")
      
        output = []
        output.extend(VMWriter.write_function(f"{self._class_name.identifier}.{subroutine.name.identifier}", self._count_locals(subroutine) + 1))
        output.extend(VMWriter.write_push("constant", table.var_count("field")))
        output.extend(VMWriter.write_call("Memory.alloc", 1))
        output.extend(VMWriter.write_pop("pointer", 0))
        output.extend(self.compile_SubroutineBody(subroutine.body, table))
        return output

    def compile_SubroutineBody(self, body, table):
        """Compiles a subroutine body."""
        output = []
        for var_dec in body.var_decs:
            output.extend(self.compile_VarDec(var_dec, table))
        output.extend(self.compile_Statements(body.statements, table))
        return output

    def compile_VarDec(self, var_dec, table):
        """Compiles varaible declarations."""
        for var_name in var_dec.var_names:
            var_type = self._get_var_type(var_dec.var_type.var_type)
            var_name = var_name.identifier
            table.define(var_name, var_type, "local")
        return []

    def compile_Statements(self, statements, table):
        """Compiles multiple statements."""
        output = []
        for statement in statements.statements:
            output.extend(self.compile_Statement(statement, table))
        return output

    def compile_Statement(self, statement, table):
        """Compiles a single statement."""
        name = statement.statement.__class__.__name__
        return getattr(self, f"compile_{name}")(statement.statement, table)

    def compile_LetStatement(self, statement, table):
        """Compiles a let statement: either RegularLetStatement or ArrayEntryLetStatement."""
        name = statement.let_statement.__class__.__name__
        return getattr(self, f"compile_{name}")(statement.let_statement, table)

    def compile_RegularLetStatement(self, statement, table):
        value = table.find(statement.var_name.identifier)
        if value is None:
            raise ComplierError(f"UNKNOWN IDENTIFIER: {statement.var_name.identifier}")
        if value[1] == "field":
            value = (value[0], "this", value[2])
 
        output = []
        output.extend(self.compile_Expression(statement.expression, table))
        output.extend(VMWriter.write_pop(value[1], value[2]))
        return output

    def compile_ArrayEntryLetStatement(self, statement, table):
        value = table.find(statement.var_name.identifier)
        if value is None:
            raise CompilerError(f"UNKNOWN IDENTIFIER: {statement.var_name.identifier}")
        if value[1] == "field":
            value = (value[0], "this", value[2])

        output = []
        output.extend(self.compile_Expression(statement.expression, table))
        output.extend(self.compile_Expression(statement.exp_index, table))
        output.extend(VMWriter.write_push(value[1], value[2]))
        output.extend(VMWriter.write_operator("add"))
        output.extend(VMWriter.write_pop("pointer", 1))
        output.extend(VMWriter.write_pop("that", 0))
        return output

    def compile_IfStatement(self, statement, table):
        """Compiles an if statement: either RegularIfStatement or IfElseStatement."""
        name = statement.if_statement.__class__.__name__
        return getattr(self, f"compile_{name}")(statement.if_statement, table)

    def compile_RegularIfStatement(self, statement, table):
        self._if_label_count += 1
        label = f"END_IF_{self._if_label_count}"

        output = []
        output.extend(self.compile_Expression(statement.expression, table))
        output.extend(VMWriter.write_operator("not"))
        output.extend(VMWriter.write_if(label))
        output.extend(self.compile_Statements(statement.statements, table))
        output.extend(VMWriter.write_label(label))
        return output

    def compile_IfElseStatement(self, statement, table):
        self._if_label_count += 1
        label1 = f"ELSE_CLAUSE_{self._if_label_count}"
        label2 = f"END_IF_{self._if_label_count}"

        output = []
        output.extend(self.compile_Expression(statement.expression, table))
        output.extend(VMWriter.write_operator("not"))
        output.extend(VMWriter.write_if(label1))
        output.extend(self.compile_Statements(statement.if_statements, table))
        output.extend(VMWriter.write_goto(label2))
        output.extend(VMWriter.write_label(label1))
        output.extend(self.compile_Statements(statement.else_statements, table))
        output.extend(VMWriter.write_label(label2))
        return output

    def compile_WhileStatement(self, statement, table):
        """Compiles a while statement."""
        self._while_label_count += 1
        label1 = f"START_WHILE_{self._while_label_count}"
        label2 = f"END_WHILE_{self._while_label_count}"

        output = []
        output.extend(VMWriter.write_label(label1))
        output.extend(self.compile_Expression(statement.expression, table))
        output.extend(VMWriter.write_operator("not"))
        output.extend(VMWriter.write_if(label2))
        output.extend(self.compile_Statements(statement.statements, table))
        output.extend(VMWriter.write_goto(label1))
        output.extend(VMWriter.write_label(label2))
        return output

    def compile_DoStatement(self, statement, table):
        """Compiles a do statement."""
        output = []
        output.extend(self.compile_SubroutineCall(statement.subroutine_call, table))
        output.extend(VMWriter.write_pop("temp", 0))
        return output

    def compile_ReturnStatement(self, statement, table):
        """Compiles a return statement: either ReturnExpressionStatement or ReturnToEndStatement."""
        name = statement.return_statement.__class__.__name__
        return getattr(self, f"compile_{name}")(statement.return_statement, table)

    def compile_ReturnExpressionStatement(self, statement, table):
        output = []
        output.extend(self.compile_Expression(statement.expression, table))
        output.extend(VMWriter.write_return())
        return output

    def compile_ReturnToEndStatement(self, statement, table):
        output = []
        output.extend(VMWriter.write_push("constant", 0))
        output.extend(VMWriter.write_return())
        return output

    def compile_Expression(self, expression, table):
        "Compiles an expression."""
        output = []
        output.extend(self.compile_Term(expression.first_term, table))
        for op, term in expression.op_term_list:
            output.extend(self.compile_Term(term, table))
            output.extend(self.compile_Op(op, table))
        return output

    def compile_Term(self, term, table):
        """Compiles a term."""
        name = term.term.__class__.__name__
        if name == "tuple":
            return self.compile_ArrayAccess(term.term, table)
        else:
            return getattr(self, f"compile_{name}")(term.term, table)

    def compile_Op(self, op, table):
        op_table = {
            "+": VMWriter.write_operator("add"),
            "-": VMWriter.write_operator("sub"),
            "&": VMWriter.write_operator("and"),
            "|": VMWriter.write_operator("or"),
            "<": VMWriter.write_operator("lt"),
            ">": VMWriter.write_operator("gt"),
            "=": VMWriter.write_operator("eq"),
            "*": VMWriter.write_call("Math.multiply", 2),
            "/": VMWriter.write_call("Math.divide", 2)
            }
        return op_table[op.op.symbol]

    def compile_IntegerConstant(self, integer_constant, table):
        """Compiles an integer constant."""
        return VMWriter.write_push("constant", int(integer_constant.integer_constant))

    def compile_StringConstant(self, string_constant, table):
        """Compiles a string constant."""
        output = []
        size = len(string_constant.string_constant)
        output.extend(VMWriter.write_push("constant", size))
        output.extend(VMWriter.write_call("String.new", 1))
        for ch in string_constant.string_constant:
            output.extend(VMWriter.write_push("constant", ord(ch)))
            output.extend(VMWriter.write_call("String.appendChar", 2))
        return output

    def compile_KeywordConstant(self, keyword_constant, table):
        """Compiles a keyword constant."""
        value = keyword_constant.constant.keyword
        if value == "true":
            output = []
            output.extend(VMWriter.write_push("constant", 1))
            output.extend(VMWriter.write_operator("neg"))
            return output
        elif value in ("false", "null"):
            return VMWriter.write_push("constant", 0)
        elif value == "this":
            return VMWriter.write_push("pointer", 0)
        raise CompilerError(f"UNKNOWN KEYWORD CONSTANT: {value}")

    def compile_Identifier(self, identifier, table):
        """Compiles an identifier."""
        value = table.find(identifier.identifier)
        if value is None:
            raise CompilerError(f"UNKNOWN IDENTIFIER: {identifier.identifier}")
        if value[1] == "field":
            value = (value[0], "this", value[2])

        _, kind, index = value
        return VMWriter.write_push(kind, index)

    def compile_ArrayAccess(self, array_access, table):
        "Compiles an array entry."""
        output = []
        output.extend(self.compile_Expression(array_access[1], table))
        output.extend(self.compile_Identifier(array_access[0], table))
        output.extend(VMWriter.write_operator("add"))
        output.extend(VMWriter.write_pop("pointer", 1))
        output.extend(VMWriter.write_push("that", 0))
        return output

    def compile_SubroutineCall(self, call, table):
        """Compiles a subroutine call: either FunctonCall, MethodCall, or StaticMethodCall."""
        name = call.subroutine_call.__class__.__name__
        return getattr(self, f"compile_{name}")(call.subroutine_call, table)

    def compile_FunctionCall(self, call, table):
        output = []
        output.extend(VMWriter.write_push("pointer", 0))
        for expression in call.expression_list:
            output.extend(self.compile_Expression(expression, table))

        output.extend(VMWriter.write_call(f"{self._class_name.identifier}.{call.function_name.identifier}", len(call.expression_list) + 1))
        return output

    def compile_MethodCall(self, call, table):
        value = table.find(call.var_name.identifier)
        if value is None:
            return self.compile_StaticMethodCall(call, table)
        if value[1] == "field":
            value = (value[0], "this", value[2])
        output = []
        output.extend(VMWriter.write_push(value[1], value[2]))
        for expression in call.expression_list:
            output.extend(self.compile_Expression(expression, table))

        output.extend(VMWriter.write_call(f"{value[0]}.{call.method_name.identifier}", len(call.expression_list) + 1))
        return output

    def compile_StaticMethodCall(self, call, table):
        class_name = ""
        if call.__class__.__name__ == "MethodCall":
            class_name = call.var_name.identifier
        else:
            class_name = call.class_name.identifier
          
        output = []
        for expression in call.expression_list:
            output.extend(self.compile_Expression(expression, table))
        
        output.extend(VMWriter.write_call(f"{class_name}.{call.method_name.identifier}", len(call.expression_list)))
        return output

    def compile_UnaryOpTerm(self, term, table):
        output = []
        output.extend(self.compile_Term(term.term, table))
        output.extend(self.compile_UnaryOp(term.op, table))
        return output

    def compile_UnaryOp(self, op, table):
        if op.op.symbol == "-":
            return VMWriter.write_operator("neg")
        elif op.op.symbol == "~":
            return VMWriter.write_operator("not")
        else:
            raise CompilerError(f"NOT UNARY OPERATOR: '{op.op.symbol}'")

    
# For syntax error exception; null operation (nothing happens)
class CompilerError(Exception):
    pass

