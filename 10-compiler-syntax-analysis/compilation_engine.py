###############################################################################
# 10-compiler-syntax-analysis/compilation_engine.py
# -------------------------------------------------
# The CompilationEngine module receives input from JackTokenizer and emits
# the program's parsed structure into an output file/stream.
# 
# The output is generated by a series of `compile_<xxx>()` routines, one for
# every syntactic element <xxx> of the Jack grammar.
###############################################################################

import re

from jack_tokenizer import JackTokenizer


class CompilationEngine:
    
    def __init__(self, tokenizer, output_file):
        """Creates a new compilation engine with the given input and output."""
        self._tokenizer = tokenizer
        self._output = output_file
        self.compile_class()
        
    def _write(self, string, indent_lvl):
        """Writes string to output file, with indents."""
        self._output.write(' '*(indent_lvl * 2) + string + '\n')

    def _write_token(self, indent_lvl):
        """Writes token to output file, with indents."""
        _xml_token = self._tokenizer.get_xml_token()
        if _xml_token:
            self._output.write(' '*(indent_lvl * 2) + _xml_token + '\n')

    def _write_token_and_advance(self, indent_lvl):
        """Writes token to output file and advances to next token."""
        self._write_token(indent_lvl)
        if self._tokenizer.has_more_tokens():
            self._tokenizer.advance()

    def compile_class(self):
        """Compiles a complete class."""
        _indent = 0
        self._write("<class>", _indent)
        if self._tokenizer.has_more_tokens():
            self._tokenizer.advance()

        # Check for <class> keyword
        if self._tokenizer.keyword() != 'class': 
            raise SyntacticError(f"In <class>: expected 'class' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        # Check for <class> name
        if not self._tokenizer.identifier():
            raise SyntacticError(f"In <class>: expected [class identifier] but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        if self._tokenizer.symbol() != '{': 
            raise SyntacticError(f"In <class>: expected '{' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        # Check and parse field var declarations
        while self._tokenizer.keyword() in ('static', 'field'):
            self.compile_class_var_dec()
        # Check and parse subroutines
        while self._tokenizer.keyword() in ('constructor', 'function', 'method'):
            self.compile_subroutine()
        
        if self._tokenizer.symbol() != '}':
            raise SyntacticError(f"In <class>: expected '}' but got '{self._tokenizer.token()}'")
        self._write_token(_indent + 1)

        self._write("</class>", _indent)

    def compile_class_var_dec(self):
        """Compiles a static declaration or a field declaration."""
        _indent = 1
        self._write("<classVarDec>", _indent)
        # Check for 'field' | 'static' keyword
        if self._tokenizer.keyword() not in ("static", "field"):
            raise SyntacticError(
                    f"In <classVarDec>: expected 'static' | 'field' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        # Check for identifier or variable type  keyword
        if self._tokenizer.keyword() not in ('int', 'char', 'boolean') and not self._tokenizer.identifier():
            raise SyntacticError(
                    f"In <classVarDec>: expected 'int' | 'char' | 'boolean' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        # Check for variable name
        if not self._tokenizer.identifier():
            raise SyntacticError(f"In <classVarDec>: expected [var identifier] but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        # Check for list of variables
        while self._tokenizer.symbol() == ',':
            self._write_token_and_advance(_indent + 1)
            if not self._tokenizer.identifier():
                raise SyntacticError(f"In <classVarDec>: expected [var identifier] but got '{self._tokenizer.token()}'")
            self._write_token_and_advance(_indent + 1)
    
        if not self._tokenizer.symbol() == ';':
            raise SyntacticError(f"In <classVarDec>: expected ';' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        self._write("</classVarDec>", _indent)

    def compile_subroutine(self):
        """Compiles a complete method, function, or constructor."""
        _indent = 1
        self._write("<subroutineDec>", _indent)
        # Check subroutine declaration keyword
        if self._tokenizer.keyword() not in ('constructor', 'function', 'method'):
            raise SyntacticError(f"In <subroutineDec>: expected 'constructor' | 'function' | 'method' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        # Check for identifier or subroutine return type declaration
        if self._tokenizer.keyword() not in ('void', 'int', 'char', 'boolean') and not self._tokenizer.identifier():
            raise SyntacticError(f"In <subroutineDec>: expected 'void' | 'int' | 'char' | 'boolean' | [identifier] but got '{self._tokenizer.token()}'")      
        self._write_token_and_advance(_indent + 1)

        # Check for function name
        if not self._tokenizer.identifier():
            raise SyntacticError(f"In <subroutineDec>: expected [function identifier] but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        if self._tokenizer.symbol() != '(':
            raise SyntacticError(f"In <subroutineDec>: expected '(' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        # Check for list of parameters
        self._write("<parameterList>", _indent + 1)
        self.compile_parameter_list()
        self._write("</parameterList>", _indent + 1)

        if self._tokenizer.symbol() != ')':
            raise SyntacticError(f"In <subroutineDec>: expected ')' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        self._write("<subroutineBody>", _indent + 1)
        if self._tokenizer.symbol() != '{':
            raise SyntacticError(f"In <subroutineBody>: expected '{' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 2)

        # Check for var declarations
        while self._tokenizer.keyword() == 'var':
            self.compile_var_dec()

        # Check for statements
        while self._tokenizer.keyword() in ('let', 'if', 'while', 'do', 'return'):
            self._stmt_indent = _indent + 2
            self.compile_statements()

        if self._tokenizer.symbol() != '}':
            raise SyntacticError(f"In <subroutineBody>: expected '}' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 2)

        self._write("</subroutineBody>", _indent + 1)
        self._write("</subroutineDec>", _indent)

    def compile_parameter_list(self):
        """Compiles a (possibly empty) parameter list, not including the enclosing '()'."""
        _indent = 3
        # Check for parameter type keyword or identifier
        if self._tokenizer.keyword() not in ('void', 'int', 'char', 'boolean') and not self._tokenizer.identifier():
            return
        
        self._write_token_and_advance(_indent)
        # Check var name
        if not self._tokenizer.identifier():
            raise SyntacticError(f"In <parameterList>: expected [var identifier] but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent)

        while self._tokenizer.symbol() == ',':
            self._write_token_and_advance(_indent)
            # Check var type or identifier
            if self._tokenizer.keyword() not in ('int', 'char', 'boolean') and not self._tokenizer.identifier():
                raise SyntacticError(f"In <parameterList>: expected 'int' | 'char' | 'boolean' | [identifier] but got '{self._tokenizer.token()}'")
            self._write_token_and_advance(_indent)
            # Check var name
            if not self._tokenizer.identifier():
                raise SyntacticError(f"In <parameterList>: expected [var identifier] but got '{self._tokenizer.token()}'")
            self._write_token_and_advance(_indent)

    def compile_var_dec(self):
        """Compiles a var declaration."""
        _indent = 3
        self._write("<varDec>", _indent)
        # Check 'var' keyword
        if self._tokenizer.keyword() != 'var':
            raise SyntacticError(f"In <varDec>: expected 'var' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        
        # Check var type or identifier
        if self._tokenizer.keyword() not in ('int', 'char', 'boolean') and not self._tokenizer.identifier():
            raise SyntacticError(f"In <varDec>: expected 'int' | 'char' | 'boolean' | [var identifier] but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        # Check var name
        if not self._tokenizer.identifier():
            raise SyntacticError(f"In <varDec>: expected [var identifier] but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        
        # check for list of variables
        while self._tokenizer.symbol() == ',':
            self._write_token_and_advance(_indent + 1)
            # Check var name
            if not self._tokenizer.identifier():
                raise SyntacticError(f"In <varDec>: expected [var identifier] but got '{self._tokenizer.token()}'")
            self._write_token_and_advance(_indent + 1)

        if self._tokenizer.symbol() != ';':
            raise SyntacticError(f"In <varDec>: expected ';' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        self._write("</varDec>", _indent)

    def compile_statements(self):
        """Compiles a sequence of statements, not including the enclosing '{}'."""
        _indent = self._stmt_indent
        self._stmt_indent = _indent + 1
        self._write("<statements>", _indent)
        while self._tokenizer.keyword() in ('do', 'let', 'while', 'return', 'if'):
            stmt_type = self._tokenizer.keyword()
            if stmt_type == 'do':
                self.compile_do()
            elif stmt_type == 'let':
                self.compile_let()
            elif stmt_type == 'while':
                self.compile_while()
            elif stmt_type == 'if':
                self.compile_if()
            elif stmt_type == 'return':
                self.compile_return()
                
        self._write("</statements>", _indent)
        self._stmt_indent = _indent

    def compile_do(self):
        """Compiles a 'do' statement."""
        _indent = self._stmt_indent
        self._write("<doStatement>", _indent)
        if self._tokenizer.keyword() != 'do':
            raise SyntacticError(f"In <doStatement>: expected 'do' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        
        # Check for subroutine call
        self._stmt_indent = _indent
        self._compile_subroutine_call()

        if self._tokenizer.symbol() != ';':
            raise SyntacticError(f"In <doStatement>: expected ';' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        self._write("</doStatement>", _indent)

    def _compile_subroutine_call(self):
        """Compiles a subroutine call."""
        _indent = self._stmt_indent + 1
        if not self._tokenizer.identifier():
            raise SyntacticError(f"In SubroutineCall: expected [identifier] but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent)

        # Check for direct function call
        if self._tokenizer.symbol() == '(':
            self._write_token_and_advance(_indent)
            self._rel_indent = _indent
            self.compile_expression_list()
            if self._tokenizer.symbol() != ')':
                raise SyntacticError(f"In SubroutineCall: expected ')' but got '{self._tokenizer.token()}'")
            self._write_token(_indent)

        # Check for method call
        elif self._tokenizer.symbol() == '.':
            self._write_token_and_advance(_indent)
            # Check for method name
            if not self._tokenizer.identifier():
                raise SyntacticError(f"In SubroutineCall: expected [method identifier] but got '{self._tokenizer.token()}'")
            self._write_token_and_advance(_indent)
            if self._tokenizer.symbol() != '(':
                raise SyntacticError(f"In SubroutineCall: expected '(' but got '{self._tokenizer.token()}'")
            self._write_token_and_advance(_indent)
            self._rel_indent = _indent
            self.compile_expression_list()
            if self._tokenizer.symbol() != ')':
                raise SyntacticError(f"In SubroutineCall: expected ')' but got '{self._tokenizer.token()}'")
            self._write_token(_indent)
        else:
            raise SyntacticError(f"In SubroutineCall: expected '(' or '.' but got '{self._tokenizer.token()}'")
        
        if self._tokenizer.has_more_tokens():
            self._tokenizer.advance()

    def compile_let(self):
        "Compiles a 'let' statement."""
        _indent = self._stmt_indent
        self._write("<letStatement>", _indent)
        # Check for 'let' keyword
        if self._tokenizer.keyword() != 'let':
            raise SyntacticError(f"In <letStatement>: expected 'let' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        
        # Check for identifier
        if not self._tokenizer.identifier():
            raise SyntacticError(f"In <letStatement>: expected [identifier] but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        
        # Check for array access
        if self._tokenizer.symbol() == '[':
            self._write_token_and_advance(_indent + 1)
            # Check for expression
            self._rel_indent = _indent + 1
            self.compile_expression()
            if self._tokenizer.symbol() != ']':
                raise SyntacticError(f"In <letStatement>: expected ']' but got '{self._tokenizer.token()}'")
            self._write_token_and_advance(_indent + 1)

        if self._tokenizer.symbol() != '=':
            raise SyntacticError(f"In <letStatement>: expected '=' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        
        # Check for expression
        self._rel_indent = _indent + 1
        self.compile_expression()
        if self._tokenizer.symbol() != ';':
            raise SyntacticError(f"In <letStatement>: expected ';' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        
        self._write("</letStatement>", _indent)

    def compile_while(self):
        """Compiles a 'while' statement."""
        _indent = self._stmt_indent
        self._write("<whileStatement>", _indent)
        # Check for 'while' keyword
        if self._tokenizer.keyword() != 'while':
            raise SyntacticError(f"In <whileStatement>: expected 'while' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        
        if self._tokenizer.symbol() != '(':
            raise SyntacticError(f"In <whileStatement>: expected '(' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        self._rel_indent = _indent + 1
        self.compile_expression()
        if self._tokenizer.symbol() != ')':
            raise SyntacticError(f"In <whileStatement>: expected ')' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        
        if self._tokenizer.symbol() != '{':
            raise SyntacticError(f"In <whileStatement>: expected '{' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        self._stmt_indent = _indent + 1
        self.compile_statements()
        if self._tokenizer.symbol() != '}':
            raise SyntacticError(f"In <whileStatement>: expected '}' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        self._write("</whileStatement>", _indent)
        self._stmt_indent = _indent

    def compile_return(self):
        """Compiles a 'return' statement."""
        _indent = self._stmt_indent
        self._write("<returnStatement>", _indent)
        if self._tokenizer.keyword() != 'return':
            raise SyntacticError(f"In <returnStatement>: expected 'return' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        if self._tokenizer.symbol() != ';':
            # Check for expression
            self._rel_indent = _indent + 1
            self.compile_expression()

        if self._tokenizer.symbol() != ';':
            raise SyntacticError(f"In <returnStatement>: expected ';' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        self._write("</returnStatement>", _indent)

    def compile_if(self):
        """Compiles an 'if' statement, possibly with a trailing 'else' clause."""
        _indent = self._stmt_indent
        self._write("<ifStatement>", _indent)
        # Check for 'if' keyword
        if self._tokenizer.keyword() != 'if':
            raise SyntacticError(f"In <ifStatement>: expected 'if' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        
        if self._tokenizer.symbol() != '(':
            raise SyntacticError(f"In <ifStatement>: expected '(' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        self._rel_indent = _indent + 1
        self.compile_expression()
        if self._tokenizer.symbol() != ')':
            raise SyntacticError(f"In <ifStatement>: expected ')' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        if self._tokenizer.symbol() != '{':
            raise SyntacticError(f"In <ifStatement>: expected '{' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)
        self.compile_statements()
        if self._tokenizer.symbol() != '}':
            raise SyntacticError(f"In <ifStatement>: expected '}' but got '{self._tokenizer.token()}'")
        self._write_token_and_advance(_indent + 1)

        if self._tokenizer.keyword() == 'else':
            self._write_token_and_advance(_indent + 1)
            if self._tokenizer.symbol() != '{':
                raise SyntacticError(f"In <ifStatement>: expected '{' but got '{self._tokenizer.token()}'")
            self._write_token_and_advance(_indent + 1)
            self._stmt_indent  = _indent + 1
            self.compile_statements()
            if self._tokenizer.symbol() != '}':
                raise SyntacticError(f"In <ifStatement>: expected '}' but got '{self._tokenizer.token()}'")
            self._write_token_and_advance(_indent + 1)
        
        self._write("</ifStatement>", _indent)
        self._stmt_indent = _indent

    def compile_expression(self):
        """Compiles an expression."""
        _exp_indent = self._rel_indent
        self._rel_indent = self._rel_indent + 1
        self._write("<expression>", _exp_indent)
        self.compile_term()

        # Check for operator term
        while self._tokenizer.symbol() in ('+', '-', '*', '/', '&', '|', '<', '>', '='):
            self._rel_indent = _exp_indent + 1
            self._write_token_and_advance(self._rel_indent)
            self.compile_term()

        self._write("</expression>", _exp_indent)

    def compile_term(self):
        """Compiles a term.
        
        If the current token is a identifier, the routine must distinguish between a variable, an array entry,
        and a subroutine call. A single lookahead token, which may be one of '[', '(', or '.' suffices to
        distinguish between the three possibilities. Any other token is not part of this term and should not
        be advanced over.
        """
        _term_indent = self._rel_indent
        self._rel_indent = self._rel_indent + 1
        self._write("<term>", _term_indent)
        _is_term = False
        
        # Check for integer constant
        if self._tokenizer.int_val():
            _is_term = True
            self._write_token(self._rel_indent)
        # Check for string constant
        elif self._tokenizer.string_val():
            _is_term = True
            self._write_token(self._rel_indent)
        # Check for keyword constant
        elif self._tokenizer.keyword():
            if self._tokenizer.keyword() not in ('true', 'false', 'null', 'this'):
                raise SyntacticError(f"In <term>: expected 'true' | 'false' | 'null' | 'this' but got '{self._tokenizer.token()}'")
            _is_term = True
            self._write_token(self._rel_indent)
        # Check for expression
        elif self._tokenizer.symbol() == '(':
            self._write_token_and_advance(self._rel_indent)
            _exp_indent = self._rel_indent
            self.compile_expression()
            if self._tokenizer.symbol() != ')':
                raise SyntacticError(f"In <term>: expected ')' but got '{self._tokenizer.token()}'")
            _is_term = True
            self._write_token(_exp_indent)
        # Check for unary operators (negation)
        elif self._tokenizer.symbol() in ('-', '~'):
            self._write_token_and_advance(self._rel_indent)
            self.compile_term()
        # Check and determine whether variable, array entry, or subroutine call
        elif self._tokenizer.identifier():
            _is_term = self._lookahead_check()

        if _is_term == True:
            if self._tokenizer.has_more_tokens():
                self._tokenizer.advance()

        self._write("</term>", _term_indent)

    def _lookahead_check(self):
        """Lookahead a single token to determine whether a variable, an array entry, or a subroutine call."""
        _lc_indent = self._rel_indent
        self._write_token_and_advance(_lc_indent)
        _token_symbol = self._tokenizer.symbol()

        # Check for array access
        if _token_symbol == '[':
            self._write_token_and_advance(_lc_indent)
            self.compile_expression()
            if self._tokenizer.symbol() != ']':
                raise SyntacticError(f"In <term>: expected ']' but got '{self._tokenizer.token()}'")
            self._write_token(_lc_indent)
            return True
        # Check for direct subroutine call
        elif _token_symbol == '(':
            self._write_token_and_advance(_lc_indent)
            self.compile_expression_list()
            self._tokenizer.advance()
            if self._tokenizer.symbol() != ')':
                raise SyntacticError(f"In <term>: expected ')' but got '{self._tokenizer.token()}'")
            self._write_token(_lc_indent)
            return True
        # Check for variable -> subroutine call
        elif _token_symbol == '.':
            self._write_token_and_advance(_lc_indent)
            # Check for identifier
            if not self._tokenizer.identifier():
                raise SyntacticError(f"In <term>: expected [identifier] but got '{self._tokenizer.token()}'")
            self._write_token_and_advance(_lc_indent)
            if self._tokenizer.symbol() != '(':
                raise SyntacticError(f"In <term>: expected '(' but got '{self._tokenizer.token()}'")
            self._write_token_and_advance(_lc_indent)
            self.compile_expression_list()
            if self._tokenizer.symbol() != ')':
                raise SyntacticError(f"In <term>: expected ')' but got '{self._tokenizer.token()}'")
            self._write_token(_lc_indent)
            return True
        else:
            return False

    def compile_expression_list(self):
        """Compiles a (possibly empty) comma-separated list of expressions."""
        _exp_list_indent = self._rel_indent
        self._rel_indent = self._rel_indent + 1
        self._write("<expressionList>", _exp_list_indent)
        # Check for expression
        if self._tokenizer.token() != ')':
            self.compile_expression()
        # for list of expressions
        while self._tokenizer.symbol() == ',':
            self._write_token_and_advance(_exp_list_indent + 1)
            self._rel_indent = _exp_list_indent + 1
            self.compile_expression()
        self._write("</expressionList>", _exp_list_indent)

    
# For syntax error exception; null operation (nothing happens)
class SyntacticError(Exception):
    pass

